        -:    0:Source:randomtestAdventurer.c
        -:    0:Graph:randomtestAdventurer.gcno
        -:    0:Data:randomtestAdventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* -----------------------------------------------------------------------
        -:    2: * Gray Lunn
        -:    3: * CS 362, Winter 2019
        -:    4: * Random test for the Adventurer() function
        -:    5: * -----------------------------------------------------------------------
        -:    6: */
        -:    7:
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <limits.h>
        -:   13:#include <assert.h>
        -:   14:#include "rngs.h"
        -:   15:
        -:   16:// set NOISY_TEST to 0 to remove printfs from output
        -:   17:#define NOISY_TEST 1
        -:   18:
        -:   19:#define asserttrue(bool, l, r) if(bool) ;else printf("TEST FAILED: '" #bool  "' on line %d.\nLeft value: %d\t Right value: %d \n", __LINE__, l, r); // asserttrue used from piazza jonah siekkman
        -:   20:
        -:   21:
        -:   22:
        1:   23:int main() {
        -:   24:    int i, n, r, p, deckCount, discardCount, handCount;
        -:   25:
        1:   26:    int k[10] = {adventurer, council_room, feast, gardens, mine,
        -:   27:     remodel, smithy, village, baron, great_hall};
        -:   28:
        -:   29:    struct gameState G;
        -:   30:
        -:   31:
        -:   32:
        1:   33:    printf ("Testing adventurer.\n");
        -:   34:
        1:   35:    SelectStream(2);
        1:   36:    PutSeed(3);
        -:   37:
        -:   38:    // ************************************************** //
        -:   39:    // * CardEffect(Adventurer) dependencies:
        -:   40:    // * Assume game is initialized properly
        -:   41:    // * hand with adventurer card
        -:   42:    // * initialized deck (with treasures), hand, and discard
        -:   43:    // * 
        -:   44:    // * 
        -:   45:    // *
        -:   46:    // * 
        -:   47:    // *
        -:   48:    // * 
        -:   49:    // *
        -:   50:    // * 
        -:   51:    // *
        -:   52:    // * 
        -:   53:    // ************************************************** //
        -:   54:
     2001:   55:    for (n = 0; n < 2000; n++) {
     2000:   56:      	initializeGame(2, k, floor(Random()*INT_MAX), &G);
     2000:   57:        p = floor(Random() * 2);
     2000:   58:        checkCardAdventurer(p, &G);
        -:   59:    }
        -:   60:
        -:   61:
        1:   62:    exit(0);
        -:   63:}
        -:   64:
        -:   65:
     2000:   66:int checkCardAdventurer(int p, struct gameState *post) {
        -:   67:  struct gameState pre;
     2000:   68:  int bonus = Random() * INT_MAX;
        -:   69:  int r;
        -:   70:
     2000:   71:  post->hand[p][(post->handCount[p])++ - 1] = adventurer;
     2000:   72:  memcpy (&pre, post, sizeof(struct gameState));
        -:   73:
        -:   74:
        -:   75:  //  printf ("drawCard PRE: p %d HC %d DeC %d DiC %d\n",
        -:   76:  //	  p, pre.handCount[p], pre.deckCount[p], pre.discardCount[p]);
        -:   77:    
     2000:   78:  r = Adventurer(adventurer, Random()*MAX_HAND, Random()*MAX_HAND, Random()*MAX_HAND, post, post->handCount[p] - 1, &bonus);
        -:   79:
        -:   80:  //printf ("drawCard POST: p %d HC %d DeC %d DiC %d\n",
        -:   81:  //      p, post->handCount[p], post->deckCount[p], post->discardCount[p]);
        -:   82:
        -:   83:
     2000:   84:  asserttrue(r == 0, r, 0);
     2000:   85:  asserttrue(post->handCount[p] - 1 == pre.handCount[p], post->handCount[p] - 1, pre.handCount[p]);
     2000:   86:  asserttrue(post->numActions + 1 == pre.numActions, post->numActions + 1, pre.numActions);
     2000:   87:  asserttrue(post->handCount[p] >= 0, post->handCount[p], 0);
     2000:   88:  asserttrue(post->deckCount[p] >= 0, post->deckCount[p], 0);
        -:   89:
        -:   90:
     2000:   91:}
